---
title: "*biodb*: Creating a new field for entries."
author: "Pierrick Roger"
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('biodb')`"
abstract: |
  How to parse a new field for entries.
vignette: |
  %\VignetteIndexEntry{Creating a new field for entries.}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: false
  BiocStyle::pdf_document: default
---

# Introduction

In many cases, in biodb, a connector does not implement the parsing of all available data, the reason being that the amount of available data in an entry would require an excessive amount of coding. Thus the focus is set on a small number of fields, in which we are directly interested. Thus it may happen that one particular data that you see in entries on the database website is not present inside the entries of biodb. If you are interested in this data that is missing, then this vignette is for you. Follow the subsequent explanations in order to understand how to add a new data field and how to parse its value from the downloaded content.

In this vignette we will create a new field, and parse information from the entry content for setting the value of this field.

First we instantiate the package:
```{r}
mybiodb <- biodb::Biodb$new()
```

## Defining a new parsing of a field

Before going with the creation of a new field, we will look at the different ways of parsing a value for an existing *biodb* field that is not handled by a connector.
Two cases will be used as examples: `CompCsvFileConn` and the `ChebiExConn` defined for the **New Connector** vignette.

### CompCsvFileConn

The `CompCsvFileConn` class implements a connector to a local CSV file database of chemical compounds.

We use an extract from ChEBI database as the input CSV database file:
```{r}
fileUrl <- system.file("extdata", "chebi_extract_with_unknown_column.tsv", package='biodb')
```
Here is the content of this file as a data frame:
```{r}
read.table(fileUrl, header=TRUE, sep="\t", quote="")
```
In this file, the column name `elecCharge` does not correspond to any *biodb* field, thus the column will not be automatically parsed by the `CompCsvFileEntry` class. We can verify this by printing the content of an entry:
```{r}
conn <- mybiodb$getFactory()$createConn('comp.csv.file', url=fileUrl)
conn$getEntry('1932')$getFieldsAsDataframe()
```

For parsing the new column, we need to declare a mapping between the column name and the *biodb* field name (here `charge`). With the `CompCsvFileConn` class, this is done by calling the `setField()` method:
```{r}
conn$setField('charge', 'elecCharge')
```
Now the new column will be parsed when getting the entry. But before we must remove the current entry object from memory:
```{r}
conn$deleteAllEntriesFromVolatileCache() # We must first 
```
And then reload the same entry again:
```{r}
conn$getEntry('1932')$getFieldsAsDataframe()
```

### ChebiExConn

The `ChebiExConn` class implements a connector to the [ChEBI](https://www.ebi.ac.uk/chebi/) remote database.

Here we will use the new definition of a parsing expression to handle the parsing of the wanted data.

## Create a new field and parse its value

<!-- TODO use `charge` as new field?
	1. parse data to fill existing defined field in biodb
	2. define new unexisting field in biodb and parse data to fill its value
	3. explain how to do the same for a remote database? ==> Useful?
-->

## Adding a new field for a remote database

In this section we will use the ChEBI connector example from the "Creating a new connector" vignette.

First we get the ChebiEx connector files:
```{r}
defFile <- system.file("extdata", "chebi_ex.yml", package="biodb")
connFile <- system.file("extdata", "ChebiExConn.R", package="biodb")
entryFile <- system.file("extdata", "ChebiExEntry.R", package="biodb")
```

And we load the definition file as well as the classes:
```{r}
mybiodb$loadDefinitions(defFile)
source(connFile)
source(entryFile)
```

We can then create a connector to the ChEBI database:
```{r}
conn <- mybiodb$getFactory()$getConn('chebi.ex')
```

### Look at the fields already parsed

The expressions for parsing entry fields are stored inside the `parsing.expr` property:
```{r}
conn$getPropertyValue('parsing.expr')
```
The expressions are in a format called XPath that is used to describe a search into XML.

### Look at the entry content

We want to get the field `n_stars`, which indicates the number of stars, synonymous of quality, of a chemical entity. The first thing to know is understand how it is stored by ChEBI. For this we need to look at the entry content, which is in XML.

We run `getEntryContent()` to print the content of a ChEBI entry:
```{r}
cat(conn$getEntryContent('15440')[[1]])
```
Another possibility, when using the persistent cache, is to get the file path to the cache file:
```{r}
conn$getCacheFile('15440')
```
You can then open the file inside your preferred application.

Now we need to look for the information we want to extract, which is the `n_stars` indicator, and we see in the content that there is a tag `entityStar` that contains the information we want: `<entityStar>3</entityStar>`.

### Create the new field and its parsing expression

We have defined the new `n_stars` field and its parsing expression inside a YAML file:
```{r}
defFile <- system.file("extdata", "chebi_ex_stars_field.yml", package="biodb")
```
Here is its content:
```{r}
writeLines(readLines(defFile))
```
The expression `//...` is an XPath expression that used to extract information from an XML file. See [XPath Tutorial](http://www.w3schools.com/xsl/xpath_intro.asp) for an introduction to XPath.

Now we load this definition file:
```{r}
mybiodb$loadDefinitions(defFile)
```

We can check that the new definition exists:
```{r}
mybiodb$getEntryFields()$get('n_stars')
```

And delete the current connector for recreating a new one just after:
```{r}
mybiodb$getFactory()$deleteConn(conn$getId())
conn <- mybiodb$getFactory()$getConn('chebi.ex')
```
This allows the new connector to have the new parsing expression registered, as we check it here:
```{r}
conn$getPropertyValue('parsing.expr')
```

# Get the entry and see the new field

Now we can get the entry and print the value of our new field:
```{r}
entry <- conn$getEntry('15440')
entry$getFieldValue('n_stars')
```

# Closing biodb instance

Do not forget to terminate your biodb instance once you are done with it:
```{r}
mybiodb$terminate()
```
