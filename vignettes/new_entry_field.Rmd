---
title: "Creating a new field for entries."
author: "Pierrick Roger"
output:
  html_document:
    theme: null
package: biodb
abstract: |
  How to create a new field and use it to parse a value inside an entry content.
vignette: |
  %\VignetteIndexEntry{Creating a new field for entries.}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Creating a new field for entries.

## Introduction

In this vignette we will create a new field, and parse information from an entry content downloaded from a database for setting the value into the new field.

First we instantiate the package:
```{r}
mybiodb <- biodb::Biodb$new()
```

## Get an entry

For the example, we will use a connector to the LIPID MAPS Structure database:
```{r}
conn <- mybiodb$getFactory()$getConn('lipidmaps.structure')
```
This database returns its entries as CSV files, which are fairly simple to parse. A good choice for this first vignette about entry field parsing.

## Look at the fields already parsed

The expressions for parsing entry fields are stored inside the `parsing.expr` property:
```{r}
conn$getPropertyValue('parsing.expr')
```
As you can see, the parsing expressions are quite simple, they only indicate the column name where to find the field value inside the CSV file.

In order to illustrate the mechanism of field parsing, we will define a new field `formula2`, which will be the exact equivalent of the field `formula`.

## Create the new field

We have defined the new `formula2` inside a JSON file:
```{r}
field_file <- system.file("extdata", "formula2_field.json", package = "biodb")
```
Here is its content:
```{r}
writeLines(readLines(field_file))
```

Now we load this definition of a new field:
```{r}
mybiodb$getEntryFields()$loadFieldsFile(field_file)
```

And we can check that the new definition exists:
```{r}
mybiodb$getEntryFields()$get('formula2')
```

## Look at the entry content

In order to know the name of the column in which the value of our field is stored, we need to see the CSV file returned by the database web service. One way to do this, is by passing one or more entry IDs to the `getEntryContent()`:
```{r}
cat(conn$getEntryContent('LMFA00000001')[[1]])
```
Another possibility, when using the persistent cache, is to get the file path to the cache file:
```{r}
conn$getCacheFile('LMFA00000001')
```
You can then open the file inside your preferred application.

Now look for the information we want to extract, which is the chemical formula, and get the corresponding column name: `FORMULA`.

## Create the parsing expression

<!--
X	1. We need to move the constant parsing expressions into the database information file dbinfo.json
	2. We need to allow the definition of additional parsing expressions.
-->

## Forget/remove the loaded entry and remove it from the memory/volatile cache

## Get again the entry and see the new field

## Closing biodb instance

Do not forget to terminate your biodb instance once you are done with it:
```{r}
mybiodb$terminate()
```
