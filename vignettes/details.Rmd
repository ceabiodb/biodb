---
title: "Details on biodb"
author: "Pierrick Roger"
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('biodb')`"
vignette: |
  %\VignetteIndexEntry{Details on general *biodb* usage and principles}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
abstract: |
  AAA
output:
  BiocStyle::html_document:
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: false
  BiocStyle::pdf_document: default
bibliography: references.bib 
---

```{r, code=readLines(system.file('vignettes_inc.R', package='biodb')), echo=FALSE}
```

# Introduction

In this document are presented different aspects of *biodb* in more details:
the object oriented programming model adopted,
its architecture,
how to configure the package,
how to create connectors and delete them,
understanding the request scheduler,
how to tune the logging system.

# Object oriented programming (OOP) model

In R, you may already know the two classical OOP models *S3* and *S4*.
*S4* is certainly the most used model, and is based on an original system of
generic methods that can be specialized for each class.

Two more recent OOP models exist in R: *Reference Classes* (aka *RC* or *R5* from package *methods*)
and *R6* (from package *R6*).
These two models are very similar.
The *biodb* package uses a mix of *RC* and *R6*, but will switch completely to *R6* in a
near future.

They both implement an object model and based on references.
This means that each object is unique, never copied and accessed through references.
In this system, the created objects are not copied, but their reference are
copied.
Any modification of an object in one part of the code, will be visible from all
other parts of the code.
This means that when you pass an instance to a function, that function is able
to modify the instance.

Also, in *RC* and *R6*, the functions are attached to the object.
In other words, the mechanism to call a function on a object is different from *S4*.
The calling mechanism is thus slightly different, in *RC* or *R6* we write
`myObject$myFunction()` instead of `myFunction(myObject)` in S4.

See
[Reference Classes](https://www.rdocumentation.org/packages/methods/versions/3.6.0/topics/ReferenceClasses) chapter from package *methods*
and this [introduction to R6](https://r6.r-lib.org/articles/Introduction.html)
for more details.

# Initialization & termination

*biodb* uses an initialization/termination scheme. You must first initialize
the library by creating an instance of the main class `BiodbMain`:
```{r}
mybiodb <- biodb::newInst()
```
And when you are done with the library, you have to terminate the instance
explicitly:
```{r}
mybiodb$terminate()
```

We will need a *biodb* instance for the rest of this vignette. Let us call the
constructor again:
```{r}
mybiodb <- biodb::newInst()
```

# Management classes

Several class instances are attached to the *biodb* instance for managing
different aspects of *biodb*: creating connectors, configuring *biodb*,
accessing the cache system, etc.

See table \@ref(tab:mngtClasses) for a list of these instances and their
purpose.

Class                 | Method to get the instance      | Description
--------------------- | ------------------------------- | --------------------------------
BiodbConfig           | `mybiodb$getConfig()`           | Access to configuration values, and modification.
BiodbDbsInfo          | `mybiodb$getDbsInfo()`          | Databases information (name, description, request frequency, etc).
BiodbEntryFields      | `mybiodb$getEntryFields()`      | Entry fields information (description, type, cardinality, etc).
BiodbFactory          | `mybiodb$getFactory()`          | Creation of connectors and entries.
BiodbPersistentCache  | `mybiodb$getPersistentCache()`  | Cache system on disk.
BiodbRequestScheduler | `mybiodb$getRequestScheduler()` | Send requests to web servers, respecting the frequency limit for each database server.
: (\#tab:mngtClasses) The management classes.
Only one instance is created for each of theses classes, and attached to the `BiodbMain` instance,

# Configuration

Several configuration values are defined inside the `definitions.yml` file of *biodb*.
New configuration values can also be defined in extension packages.

To get a list of the existing configuration keys with their current value, run:
```{r}
mybiodb$getConfig()
```

To get a list of all keys with their descriptions, call:
```{r}
mybiodb$getConfig()$listKeys()
```

To get the description of a key, run:
```{r}
mybiodb$getConfig()$getDescription('cache.directory')
```

To get a value, run:
```{r}
mybiodb$getConfig()$get('cache.directory')
```

To set a field value, run:
```{r}
mybiodb$getConfig()$set('cache.directory', '~/my.biodb.cache')
```

If the field is boolean, you can use the following methods instead:
```{r}
mybiodb$getConfig()$enable('offline')
mybiodb$getConfig()$disable('offline')
```

Configuration keys have default values. 
You can get a key's default value with this call:
```{r}
mybiodb$getConfig()$getDefaultValue('cache.directory')
```

Environment variables can be used to overwrite default values.
To get the name of the environment variable associated with a particular key,
call the following method:
```{r}
mybiodb$getConfig()$getAssocEnvVar('cache.directory')
```

## Factory

Get the factory instance:
```{r}
fact <- mybiodb$getFactory()
```

## Cache system

## Databases information

Get the databases info instance:
```{r}
dbsinfo <- mybiodb$getDbsInfo()
```

List available connectors:
```{r}
dbsinfo$getIds()
```

## Entry fields information

Get the entry fields instance:
```{r}
fieldDefs <- mybiodb$getEntryFields()
```

Get information about a field:
```{r}
fieldDefs$get('monoisotopic.mass')
```

# Connector and entry classes

<!-- TODO
Connectors:
 * Share the same methods through the common super classes `BiodbConn`, `BiodbRemotedbConn`, ...
Entries:
 * Share the same methods through the common super class `BiodbEntry`.
 * the definition of fields are in common between database, thus the same field will have the same name in two entries of two different databases.
 Factory :
  * creates a new connector (createConn)
  * stores connectors in memory.
  * gives you back an existing connector (getConn)
  * creates entries
  * stores entries in memory (volatile cache).
  * gives you back existing entries (instead of reloading them)
  * you can delete entries from memory
  * you can delete connectors from memory
URL request scheduler:
 * run requests on a database server.
 * controls the frequency of requests for a database server.
 * Use the cache system to store results of requests.
 * Use cached request result instead of sending again the request.
Cache system :
a
 * stores entries on disk (persistence cache).
 * gives back entries instead of reloading them from database.
 * allows you to delete cached entries from disk.
 * allows you to delete all cached files for a database.
-->

# Available database connectors

This package is delivered with two connectors for local databasses:
MassCsvFile annd MassSqlite. However it is extendable, and in fact other
packages already exist or will soon be made available on Bioconductor or
GitHub for accessing other databases like ChEBI, Uniprot, HMDB, KEGG,
Massbank or Lipidmaps.  You may also write your own connector by extending
*biodb*. If you are interested, a vignette explains what you need to do in
details.

When creating the instance of the `BiodbMain` class you should have received a
message like "Loading definitions from package ..." if any extending package
has also been installed on your system. Connector definitions found in
extending packages are automatically loaded when instantiating `BiodbMain`, thus
you do not need to call `library()` to individually load each extending
package.

To get a list of available connectors, simply print information about your
`BiodbMain` instance:
```
mybiodb
```

# Getting a database connector

To access a database you need a connector that you obtain from
the factory instance. Here is an example with a compound CSV file database:
```{r}
chebi.tsv <- system.file("extdata", "chebi_extract.tsv", package='biodb')
conn <- mybiodb$getFactory()$createConn('comp.csv.file', url=chebi.tsv)
```

Then the connector allows you to send requests to the database
to retrieve entries directly or run more complex queries:
```{r}
conn$getEntry('1018')
conn$searchCompound(mass=136.05, mass.field='monoisotopic.mass')
```

# Entries

Get an entry:
```{r}
entry <- conn$getEntry('1018')
```

Get a list of available fields for this entry:
```{r}
entry$getFieldNames()
```

Get a field value from an entry:
```{r}
entry$getFieldValue('accession')
entry$getFieldValue('monoisotopic.mass')
```

Export all field values as a data frame:
```{r}
entry$getFieldsAsDataframe()
```

# Logging messages

*biodb* implements five level of messages:
* `error` which is mapped to R error messages.
* `warning` which is mapped to R warning messages.
* `caution` which uses R message() method.
* `info` which uses R message() method.
* `debug` which uses R message() method.

The three last (`caution`, `info` and `debug`) use each multiple levels.
By default debug messages are disabled. To change the level of a message
type, you need to access its configuration variable. Here we silence the
caution and info messages by setting their maximum level allowed to 0:
```{r}
mybiodb$getConfig()$set('msg.caution.lvl', 0)
mybiodb$getConfig()$set('msg.info.lvl', 0)
```

Stop information messages of the BiodbMain instance:
```{r}
#cfg$set('msg.info.lvl', 0)
```

Increase verbosity level of the BiodbMain instance:
```{r}
#cfg$set('msg.info.lvl', 2)
#cfg$set('msg.debug.lvl', 2)
#cfg$set('msg.caution.lvl', 2)
```

# Closing biodb instance

Do not forget to terminate your biodb instance once you are done with it:
```{r}
mybiodb$terminate()
```

# References
